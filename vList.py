class list():
    def __init__(self) -> None:
    # def copy(self) -> list[_T]: ...
    def append(self, __object: _T) -> None: ...
    def extend(self, __iterable: Iterable[_T]) -> None: ...
    # def pop(self, __index: SupportsIndex = ...) -> _T: ...
    def index(self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...) -> int: ...
    # def count(self, __value: _T) -> int: ...
    # def insert(self, __index: SupportsIndex, __object: _T) -> None: ...
    # def remove(self, __value: _T) -> None: ...
    # Signature of `list.sort` should be kept inline with `collections.UserList.sort()`
    # and multiprocessing.managers.ListProxy.sort()
    #
    # Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]
    # to work around invariance
    # def sort(self: list[SupportsRichComparisonT], *, key: None = ..., reverse: bool = ...) -> None: ...
    # def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    # def __getitem__(self, __i: SupportsIndex) -> _T: ...
    # def __setitem__(self, __i: SupportsIndex, __o: _T) -> None: ...
    # def __add__(self, __x: list[_T]) -> list[_T]: ...
    # def __mul__(self, __n: SupportsIndex) -> list[_T]: ...
    # def __contains__(self, __o: object) -> bool: ...
    # def __reversed__(self) -> Iterator[_T]: ...
    # def __gt__(self, __x: list[_T]) -> bool: ...
    # def __lt__(self, __x: list[_T]) -> bool: ...
    # def __le__(self, __x: list[_T]) -> bool: ...

    